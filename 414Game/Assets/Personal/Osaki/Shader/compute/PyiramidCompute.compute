// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

float3 GetNormalForomTriangle(float3 a, float3 b, float3 c)
{
	return normalize(cross(b - a, c - a));
}

float3 GetTriangleCenter(float3 a, float3 b, float3 c)
{
	return (a + b + c) / 3;
}

float2 GetTriangleCenter(float2 a, float2 b, float2 c)
{
	return (a + b + c) / 3;
}

struct SourceVertex
{
	float3 positionOS;	// object space
	float2 uv;
};

struct DrawVertex
{
	float3 positionWS;
	float2 uv;
};

struct DrawTriangle
{
	float3 normalWS;	// world space
	DrawVertex vertices[3];
};

// Compute Buffer
StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceTriangles;
AppendStructuredBuffer<DrawTriangle> _DrawTriangles;

// property
int _NumSourceTriangles;
float _PyramidHeight;
float4x4 _LocalToWorld;

DrawVertex TransformToWorldSpace(SourceVertex v)
{
	DrawVertex o;
	o.positionWS = mul(_LocalToWorld, float4(v.positionOS, 1)).xyz;
	o.uv = v.uv;
	return o;
}

void SetupAndOutputTriangle(DrawVertex a, DrawVertex b, DrawVertex c)
{
	float3 normalWS = GetNormalForomTriangle(a.positionWS, b.positionWS, c.positionWS);
	
	DrawTriangle tri;
	tri.normalWS = normalWS;
	tri.vertices[0] = a;
	tri.vertices[1] = b;
	tri.vertices[2] = c;

	_DrawTriangles.Append(tri);
}

[numthreads(128, 1, 1)]
void Main(uint3 id : SV_DispatchThreadID)
{
	if ((int)id.x >= _NumSourceTriangles)
	{
		return;
	}

	int triStart = id.x * 3;
	DrawVertex inputs[3];
	inputs[0] = TransformToWorldSpace(_SourceVertices[_SourceTriangles[triStart]]);
	inputs[1] = TransformToWorldSpace(_SourceVertices[_SourceTriangles[triStart + 1]]);
	inputs[2] = TransformToWorldSpace(_SourceVertices[_SourceTriangles[triStart + 2]]);

	DrawVertex center;
	float3 triNormal = GetNormalForomTriangle(inputs[0].positionWS, inputs[1].positionWS, inputs[2].positionWS);
	center.positionWS = GetTriangleCenter(inputs[0].positionWS, inputs[1].positionWS, inputs[2].positionWS) + triNormal * _PyramidHeight;
	center.uv = GetTriangleCenter(inputs[0].uv, inputs[1].uv, inputs[2].uv);

	SetupAndOutputTriangle(inputs[0], inputs[1], center);
	SetupAndOutputTriangle(inputs[1], inputs[2], center);
	SetupAndOutputTriangle(inputs[2], inputs[0], center);
}